# Python 14: Higher Order Functions.

**Introduction**: This document presents learning activities for Python 14. In Python 14, you will practice basics of higher order functions in Python.

**Note**: In this phase, it is expected the learner can plan and run required learning process towards the goals of the week: making solutions to the given problems and product(s).

## Materials:

The activities are designed based on these following references:

- **BRef-01**: Book, Bill Lubanovic; "Introducing Python: Modern Computing in Simple Packages"; [Available here](https://www.oreilly.com/library/view/introducing-python-2nd/9781492051374/) 

- Free research.

## Path:

### Step: Functions Are First-Class Citizens.

#### Goals:

```
After taking this step, you will be able to:
	1. understand programs using: functions as parameters, generators and decorators.
```

#### What to learn?

1. Using **BRef-01, Chapter 9** (after section **Functions Are First-Class Citizens**) make a plan for the week to learn basics of higher order functions (HOF).
	- Read proposed book chapter and practice basic steps.

<hr>

## Exercises:

1. *Functions can be assigned to different variables*. Read the code given below and write down the result of the program:

```python
def f(x):
    return x*x
double = f
print(double(3) , f(5))

```
2. *Functions can be collected within a structure*. Read the code given below and write down the result of the program:
```python
def f(x):
    return x**2
    
def g(x):
    return x**3
funcs = [f, g]
#accessing elements of the list separately
print(funcs[0](10), funcs[1](10))
# iterating over functions
for i in funcs: 
    print(i(5))
```
3. *Functions as arguments to functions*. Read the code given below and write down the result of the program: 

```python
names = ['Ann','Benjamin','Alexander','Michael']
print(sorted(names)) # what will be printed here? Why?
print(sorted(names,key=len)) # what will be printed here? Why?
print(sorted(names,key=lambda x: x[1] if type(x) is str and len(x)>2 else None)) # what will be printed here? Why?
```

3. *Generators*. Read the code given below. Function `power_n_range` is implementing a *generator*. It will generate a sequence of `x` to the power of `n` where `x` is between `first` and `last`. Using a `for`-loop, iterate over the elements generated by `power_n_range` with different values for parameters.

```python
def power_n_range(first=0,last=1,n=1):
    for x in range(first,last):
        yield x**n
# complete the code here
```
4. *Decorators*. Take the function `power_n_range` from the previous exercise. We would like to decorate the function such that it provides better printing. For example, printing the sequence of `power_n_range(0,3,3)` will result as the following:
```
0^3 = 0
1^3 = 1
2^3 = 8
```
Make the given code complete and experiment with various values.

```python
def pretty_print(func):
#todo: implement the body of this function


#todo: put required syntactic sugar
def power_n_range(first=0,last=1,n=1):
    for x in range(first,last):
        yield x**n

#todo: implement a for-loop to iterate over generated sequence. Experiment with and without syntactic sugar.
```
## Problems:

1. The idea is to sort a list of strings. Depending on the purpose of the sorting, the criteria of sorting can be different: alphabetically based on the first letter, length of the string, etc. Use the code template below and implement sorting based on the number of vowels (descending) within a string. For example, `fall` will step before `free`.

```python

def get_num_of_vowels(inp:str)->int:
    vowel_count = 0
    # todo: implement the body of the function
    return vowel_count
def sort_basedon_vowels():
    cases = ['code','programming','description','fly','free']
    print(sorted(cases)) # todo: fix the call of the function

sort_basedon_vowels()
```

2. One of the ways to measure the performance of pieces of a code is to measuer the time of the execution. For example, the time is recorded at the begining and at the end of a function. Then, the execution time can be calculated. A desirable implementation is to not change the body of an already implemented function. A decorator can be helpful here. Suppose you have an already implemented function. Decorate your function such the its execution time is printed.


<!-- todo: a draft for an optional problem (not complete yet)
3. Usually, processing a dataset a regular function holds the values in (main) memory, known as RAM memory, and returns them to the caller. Suppose you need to implement a function that returns the content of a file for various purposes, like searching, sending over the network, processing, etc. Assume the size of the file is very large (1000,000,000+ rows). As you have learned before, one usual solution would be to open the file, load all the rows as a list (using `readlines`) and return the list. This may not be a proper solution in a large file. 
	- Why this may not be a proper solution? Try to make an experiment. Implement a short code that writes a sring (any text is fine) of length 10 in 1000,000,000 lines. Then in a different code, as you have learned so far, open the file, read the lines and search for `hello` (`hello` should be in the content). Share your experiemnt with your teacher and classmates. *Hint:* First, calculate how much space is available in your hard disk and make sure you have enough space (Question: How much space do you need for 1000,000,000 lines of a string with length of 10?). **Don't forget: in your program you close the file after writing**. Before trying with 1000,000,000 rows test your program with 100 rows.
    - Try to monitor memory usage when you test your program. What is your observation?
	- What would be your solution for reading and processing files with large content? *Hint:* Use *generator function*. A generator function doesnâ€™t hold the values in the main memory. It can deliver each row over time as the caller requests them.
-->


## Assignment:

**Background** One of the features that usually software engineers try to consider in their programs is *maintainability*. The idea is to implement your code such that later can be evolved with less need to change. 

**Assignment** Consider the assignment of **week 7** [click here](https://github.com/afshinamighi/Courses/blob/main/basecamp/week07/inf-bc-w07-python.md). Your solution more likely is relying on a dictionary as a data structure that maps keys to values (to encode / decode a text). Suppose you are asked to make your solution more generic such that if the mapping mechanism / algorithm / structure changes in the future, then your implementation for the other functions, mainly encoding and decoding, remain without any changes. For example, in the future, instead of perdefined mapping table, the value for a given key is calculated based on an algorithm. Or a different data structure is used instead of a dictionary. What would be your proposal?
	- Propose your solution and refactor your already existing solution such that it implements your proposal. 
    - Assume in the future the algorithm of mappings the keys will change several times. Highlight pieces of your previous solution where get influenced by this change. Compare it with your new solution. Which one would need less change?

## Extra Steps:

Extra resources:

1. [Higher-Order Functions and Decorators](https://medium.com/python-supply/higher-order-functions-and-decorators-d6bb31a5c78d)