# Python 14: Higher Order Functions.

**Introduction**: This document presents learning activities for Python 14. In Python 14, you will practice basics of higher order functions in Python.

**Note**: In this phase, it is expected the learner can plan and run required learning process towards the goals of the week: making solutions to the given problems and product(s).

## Materials:

The activities are designed based on these following references:

- **BRef-01**: Book, Bill Lubanovic; "Introducing Python: Modern Computing in Simple Packages"; [Available here](https://www.oreilly.com/library/view/introducing-python-2nd/9781492051374/) 

- Free research.

## Path:

### Step: Functions Are First-Class Citizens.

#### Goals:

```
After taking this step, you will be able to:
	1. understand programs using: functions as parameters, generators and decorators.
```

#### What to learn?

1. Using **BRef-01, Chapter 9** (after section **Functions Are First-Class Citizens**) make a plan for the week to learn basics of higher order functions (HOF).
	- Read proposed book chapter and practice basic steps.

<hr>

## Exercises:

1. *Functions can be assigned to different variables*. Read the code given below and write down the result of the program:

```python
def f(x):
    return x*x
double = f
print(double(3) , f(5))

```
2. *Functions can be collected within a structure*. Read the code given below and write down the result of the program:
```python
def f(x):
    return x**2
    
def g(x):
    return x**3
funcs = [f, g]
#accessing elements of the list separately
print(funcs[0](10), funcs[1](10))
# iterating over functions
for i in funcs: 
    print(i(5))
```
3. *Functions as arguments to functions*. Read the code given below and write down the result of the program: 

```python
names = ['Ann','Benjamin','Alexander','Michael']
print(sorted(names)) # what will be printed here? Why?
print(sorted(names,key=len)) # what will be printed here? Why?
print(sorted(names,key=lambda x: x[1] if type(x) is str and len(x)>2 else None)) # what will be printed here? Why?
```

3. *Generators*. Read the code given below. Function `power_n_range` is implementing a *generator*. It will generate a sequence of `x` to the power of `n` where `x` is between `first` and `last`. Using a `for`-loop, iterate over the elements generated by `power_n_range` with different values for parameters.

```python
def power_n_range(first=0,last=1,n=1):
    for x in range(first,last):
        yield x**n
# complete the code here
```
4. *Decorators*. Someone has implemented the following division function. If we test the functions carefully, we will realize that there will be an error if `b==0` (why?), for example: `division(10,0)`. Of course one solution is to change the implementation of the function. Another solution would be to decorate the currently existing one with a new feature that checks if it is not division by zero. 

```python
def division(a,b):
    return a/b
```

Complete the following template such that it decorates our division function with a check.

```python
def division_fixed(func):
    def check_params(a,b):
        #todo: complete the code here
        
        return check_params

    
@division_fixed
def division(a,b):
    return a/b

print(division(10,2))
print(division(10,0)) # This must not raise an error
```


## Problems:

1. The idea is to sort a list of strings. Depending on the purpose of the sorting, the criteria of sorting can be different: alphabetically based on the first letter, length of the string, etc. Use the code template below and implement sorting based on the number of vowels (descending) within a string. For example, `fall` will step before `free`.

```python

def get_num_of_vowels(inp:str)->int:
    vowel_count = 0
    # todo: implement the body of the function
    return vowel_count
def sort_basedon_vowels():
    cases = ['code','programming','description','fly','free']
    print(sorted(cases)) # todo: fix the call of the function

sort_basedon_vowels()
```

2. One of the ways to measure the performance of pieces of a code is to measuer the time of the execution. For example, the time is recorded at the begining and at the end of a function. Then, the execution time can be calculated. A desirable implementation is to not change the body of an already implemented function. A decorator can be helpful here. Suppose you have an already implemented function. Decorate your function such the its execution time is printed.



## Assignment:

**Background** One of the features that usually software engineers try to consider in their programs is *maintainability*. The idea is to implement your code such that later can be evolved with less need to change. 

**Assignment** Consider the assignment of **week 7** ([click here](https://github.com/afshinamighi/Courses/blob/main/basecamp/week07/inf-bc-w07-python.md)). Your solution more likely is relying on a dictionary as a data structure that maps keys to values (to encode / decode a text). Suppose you are asked to make your solution more generic such that if the mapping mechanism / algorithm / structure changes in the future, then your implementation for the other functions, mainly encoding and decoding, remains without any changes. For example, in the future, instead of perdefined mapping table, the value for a given key is calculated based on an algorithm. Or a different data structure is used instead of a dictionary. What would be your proposal?

- Propose your solution and refactor your already existing solution such that it implements your proposal. Update the `encode_string`  and `decode_string` functions so instead of a key, they use a function to do the encoding/decoding with.

```python
def encode_sting(data: str, encode_function) -> str:
def decode_string(data: str, decode_function) -> str:
```

- Assume in the future the algorithm of mappings the keys will change several times. Highlight pieces of your previous solution where get influenced by this change. Compare it with your new solution. Which one would need less change?



## Extra Steps:

Extra resources:

1. [Higher-Order Functions and Decorators](https://medium.com/python-supply/higher-order-functions-and-decorators-d6bb31a5c78d)


<!--
Take the function `power_n_range` from the previous exercise. We would like to decorate the function such that it provides better printing. For example, printing the sequence of `power_n_range(0,3,3)` will result as the following:
```
0^3 = 0
1^3 = 1
2^3 = 8
```
Make the given code complete and experiment with various values.

```python
def pretty_print(func):
#todo: implement the body of this function


#todo: put required syntactic sugar
def power_n_range(first=0,last=1,n=1):
    for x in range(first,last):
        yield x**n

#todo: implement a for-loop to iterate over generated sequence. Experiment with and without syntactic sugar.
```
-->